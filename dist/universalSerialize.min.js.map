{"version":3,"sources":["webpack://universal-serialize/webpack/universalModuleDefinition","webpack://universal-serialize/webpack/bootstrap","webpack://universal-serialize/./src/constants.js","webpack://universal-serialize/./src/common.js","webpack://universal-serialize/./src/serializers/function.js","webpack://universal-serialize/./src/serializers/error.js","webpack://universal-serialize/./src/serializers/promise.js","webpack://universal-serialize/./src/serializers/regex.js","webpack://universal-serialize/./src/serializers/date.js","webpack://universal-serialize/./src/serializers/array.js","webpack://universal-serialize/./src/serializers/object.js","webpack://universal-serialize/./src/serializers/string.js","webpack://universal-serialize/./src/serializers/number.js","webpack://universal-serialize/./src/serializers/boolean.js","webpack://universal-serialize/./src/serializers/null.js","webpack://universal-serialize/./src/serialize.js","webpack://universal-serialize/./src/deserialize.js","webpack://universal-serialize/./src/types.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","hasOwnProperty","p","s","TYPE","FUNCTION","ERROR","PROMISE","REGEX","DATE","ARRAY","OBJECT","STRING","NUMBER","BOOLEAN","NULL","UNDEFINED","isSerializedType","item","__type__","determineType","val","Array","isArray","Error","then","toString","serializeType","type","__val__","serializeFunction","deserializeFunction","serializeError","message","stack","code","deserializeError","error","serializePromise","deserializePromise","serializeRegex","source","deserializeRegex","RegExp","serializeDate","toJSON","deserializeDate","Date","serializeArray","deserializeArray","serializeObject","deserializeObject","serializeString","deserializeString","serializeNumber","deserializeNumber","serializeBoolean","deserializeBoolean","serializeNull","deserializeNull","SERIALIZER","defaultSerializers","serialize","obj","serializers","result","JSON","stringify","serializer","DESERIALIZER","defaultDeserializers","deserialize","str","deserializers","parse","deserializer","TYPES"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,sBAAuB,GAAIH,GACR,iBAAZC,QACdA,QAAQ,uBAAyBD,IAEjCD,EAAK,uBAAyBC,IARhC,CASoB,oBAATK,KAAuBA,KAAOC,MAAO,WAChD,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUR,QAGnC,IAAIC,EAASK,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHV,QAAS,IAUV,OANAW,EAAQH,GAAUI,KAAKX,EAAOD,QAASC,EAAQA,EAAOD,QAASO,GAG/DN,EAAOS,GAAI,EAGJT,EAAOD,QA0Df,OArDAO,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASf,EAASgB,EAAMC,GAC3CV,EAAoBW,EAAElB,EAASgB,IAClCG,OAAOC,eAAepB,EAASgB,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAASvB,GACX,oBAAXwB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAepB,EAASwB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAepB,EAAS,aAAc,CAAE0B,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAASjC,GAChC,IAAIgB,EAAShB,GAAUA,EAAO4B,WAC7B,WAAwB,OAAO5B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAM,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,MAAOjB,GAAiBkB,eAAezB,KAAKuB,EAAQC,IAGzG7B,EAAoB+B,EAAI,GAIjB/B,EAAoBA,EAAoBgC,EAAI,G,o4CChF9C,I,EAAMC,EAAO,CAChBC,SAAY,WACZC,MAAY,QACZC,QAAY,UACZC,MAAY,QACZC,KAAY,OACZC,MAAY,QACZC,OAAY,SACZC,OAAY,SACZC,OAAY,SACZC,QAAY,UACZC,KAAY,OACZC,UAAY,aCTT,SAASC,EAAiBC,GAC7B,MAAwB,iBAATA,GAA8B,OAATA,GAA0C,iBAAlBA,EAAKC,SAG9D,SAASC,EAAcC,GAC1B,YAAmB,IAARA,EACAjB,EAAKY,UAGJ,OAARK,EACOjB,EAAKW,KAGZO,MAAMC,QAAQF,GACPjB,EAAKM,MAGG,mBAARW,EACAjB,EAAKC,SAGG,iBAARgB,EAEHA,aAAeG,MACRpB,EAAKE,MAGQ,mBAAbe,EAAII,KACJrB,EAAKG,QAG4B,oBAAxCxB,GAAiB2C,SAASlD,KAAK6C,GACxBjB,EAAKI,MAG4B,kBAAxCzB,GAAiB2C,SAASlD,KAAK6C,GACxBjB,EAAKK,KAGTL,EAAKO,OAGG,iBAARU,EACAjB,EAAKQ,OAGG,iBAARS,EACAjB,EAAKS,OAGG,kBAARQ,EACAjB,EAAKU,aADhB,EAKG,SAASa,EAAqCC,EAAUP,GAC3D,MAAO,CACHF,SAAUS,EACVC,QAAUR,GC3DX,SAASS,KAIT,SAASC,IACZ,MAAM,IAAIP,MAAJ,qECIH,SAASQ,EAAT,GACH,OAAOL,EAAcvB,EAAKE,MAAO,CAAE2B,QADqF,EAA3FA,QACeC,MAD4E,EAAlFA,MACaC,KADqE,EAA3EA,OAI1C,SAASC,EAAT,GAA8E,IAAzCF,EAAyC,EAAzCA,MAAOC,EAAkC,EAAlCA,KACzCE,EAAQ,IAAIb,MAD+D,EAAlDS,SAK/B,OAFAI,EAAMF,KAAOA,EACbE,EAAMH,MAAYA,EAAlB,OAAgCG,EAAMH,MAC/BG,EClBJ,SAASC,KAIT,SAASC,IACZ,MAAM,IAAIf,MAAJ,oECDH,SAASgB,EAAenB,GAC3B,OAAOM,EAAcvB,EAAKI,MAAOa,EAAIoB,QAGlC,SAASC,EAAiBrB,GAE7B,OAAO,IAAIsB,OAAOtB,GCNf,SAASuB,EAAcvB,GAC1B,OAAOM,EAAcvB,EAAKK,KAAMY,EAAIwB,UAGjC,SAASC,EAAgBzB,GAC5B,OAAO,IAAI0B,KAAK1B,GCTb,SAAS2B,EAA0B3B,GACtC,OAAOA,EAGJ,SAAS4B,EAA4B5B,GACxC,OAAOA,ECLJ,SAAS6B,EAAgB7B,GAC5B,OAAOA,EAGJ,SAAS8B,EAAkB9B,GAC9B,OAAOA,ECLJ,SAAS+B,EAAgB/B,GAC5B,OAAOA,EAGJ,SAASgC,EAAkBhC,GAC9B,OAAOA,ECLJ,SAASiC,EAAgBjC,GAC5B,OAAOA,EAGJ,SAASkC,EAAkBlC,GAC9B,OAAOA,ECLJ,SAASmC,EAAiBnC,GAC7B,OAAOA,EAGJ,SAASoC,EAAmBpC,GAC/B,OAAOA,ECLJ,SAASqC,EAAcrC,GAC1B,OAAOA,EAGJ,SAASsC,EAAgBtC,GAC5B,OAAOA,EC8BX,I,EAAMuC,IAAwB,MACxBxD,EAAKC,UAAayB,EADM,EAExB1B,EAAKE,OAAa0B,EAFM,EAGxB5B,EAAKG,SAAa+B,EAHM,EAIxBlC,EAAKI,OAAagC,EAJM,EAKxBpC,EAAKK,MAAamC,EALM,EAMxBxC,EAAKM,OAAasC,EANM,EAOxB5C,EAAKO,QAAauC,EAPM,EAQxB9C,EAAKQ,QAAawC,EARM,EASxBhD,EAAKS,QAAayC,EATM,EAUxBlD,EAAKU,SAAa0C,EAVM,EAWxBpD,EAAKW,MAAa2C,EAXM,GAexBG,EAAmC,GAElC,SAASC,EAAqBC,EAASC,QAAyD,IAAzDA,MAA4BH,GAyBtE,IAAMI,EAASC,KAAKC,UAAUJ,GAvB9B,SAAkBnE,GACd,IAAMyB,EAAMpD,KAAK2B,GAEjB,GAAIqB,EAAiBhD,MACjB,OAAOoD,EAGX,IAAMO,EAAOR,EAAcC,GAE3B,IAAKO,EACD,OAAOP,EAIX,IAAM+C,EAAaJ,EAAYpC,IAASgC,EAAWhC,GAEnD,OAAKwC,EAIEA,EAAW/C,EAAKzB,GAHZyB,KAQf,YAAsB,IAAX4C,EACA7D,EAAKY,UAGTiD,ECjDX,IAAMI,IAA4B,MAC5BjE,EAAKC,UAAa0B,EADU,EAE5B3B,EAAKE,OAAa8B,EAFU,EAG5BhC,EAAKG,SAAagC,EAHU,EAI5BnC,EAAKI,OAAakC,EAJU,EAK5BtC,EAAKK,MAAaqC,EALU,EAM5B1C,EAAKM,OAAauC,EANU,EAO5B7C,EAAKO,QAAawC,EAPU,EAQ5B/C,EAAKQ,QAAayC,EARU,EAS5BjD,EAAKS,QAAa0C,EATU,EAU5BnD,EAAKU,SAAa2C,EAVU,EAW5BrD,EAAKW,MAAa4C,EAXU,GAe5BW,EAAuC,GAEtC,SAASC,EAAqCC,EAAcC,GAC/D,QADyH,IAA1DA,MAAgCH,GAC3FE,IAAQpE,EAAKY,UAmCjB,OAAOkD,KAAKQ,MAAMF,GA9BlB,SAAkB5E,EAAKyB,GACnB,GAAIJ,EAAiBhD,MACjB,OAAOoD,EAGX,IAAIO,EACAtC,EAUJ,GARI2B,EAAiBI,IACjBO,EAAOP,EAAIF,SACX7B,EAAQ+B,EAAIQ,UAEZD,EAAOR,EAAcC,GACrB/B,EAAQ+B,IAGPO,EACD,OAAOtC,EAIX,IAAMqF,EAAeF,EAAc7C,IAASyC,EAAazC,GAEzD,OAAK+C,EAIEA,EAAarF,EAAOM,GAHhBN,KChFZ,IAAMsF,GAAQ","file":"universalSerialize.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"universal-serialize\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"universal-serialize\"] = factory();\n\telse\n\t\troot[\"universal-serialize\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/* @flow */\n\nexport const TYPE = {\n    FUNCTION:  ('function' : 'function'),\n    ERROR:     ('error' : 'error'),\n    PROMISE:   ('promise' : 'promise'),\n    REGEX:     ('regex' : 'regex'),\n    DATE:      ('date' : 'date'),\n    ARRAY:     ('array' : 'array'),\n    OBJECT:    ('object' : 'object'),\n    STRING:    ('string' : 'string'),\n    NUMBER:    ('number' : 'number'),\n    BOOLEAN:   ('boolean' : 'boolean'),\n    NULL:      ('null' : 'null'),\n    UNDEFINED: ('undefined' : 'undefined')\n};\n","/* @flow */\n\nimport { TYPE } from './constants';\nimport type { CustomSerializedType } from './types';\n\nexport function isSerializedType(item : mixed) : boolean {\n    return (typeof item === 'object' && item !== null && typeof item.__type__ === 'string');\n}\n\nexport function determineType(val : mixed) : $Values<typeof TYPE> | void {\n    if (typeof val === 'undefined') {\n        return TYPE.UNDEFINED;\n    }\n\n    if (val === null) {\n        return TYPE.NULL;\n    }\n\n    if (Array.isArray(val)) {\n        return TYPE.ARRAY;\n    }\n\n    if (typeof val === 'function') {\n        return TYPE.FUNCTION;\n    }\n\n    if (typeof val === 'object') {\n\n        if (val instanceof Error) {\n            return TYPE.ERROR;\n        }\n\n        if (typeof val.then === 'function') {\n            return TYPE.PROMISE;\n        }\n\n        if (Object.prototype.toString.call(val) === '[object RegExp]') {\n            return TYPE.REGEX;\n        }\n\n        if (Object.prototype.toString.call(val) === '[object Date]') {\n            return TYPE.DATE;\n        }\n\n        return TYPE.OBJECT;\n    }\n\n    if (typeof val === 'string') {\n        return TYPE.STRING;\n    }\n\n    if (typeof val === 'number') {\n        return TYPE.NUMBER;\n    }\n\n    if (typeof val === 'boolean') {\n        return TYPE.BOOLEAN;\n    }\n}\n\nexport function serializeType<T : string, V : mixed>(type : T, val : V) : CustomSerializedType<T, V> {\n    return {\n        __type__: type,\n        __val__:  val\n    };\n}\n","/* @flow */\n\nexport type SerializedFunction = void;\n\nexport function serializeFunction() : SerializedFunction {\n    // pass\n}\n\nexport function deserializeFunction() {\n    throw new Error(`Function serialization is not implemented; nothing to deserialize`);\n}\n","/* @flow */\n\nimport { serializeType } from '../common';\nimport { TYPE } from '../constants';\nimport type { NativeSerializedType } from '../types';\n\nexport type SerializedError = {|\n    message : string,\n    stack : string,\n    code : string | number | void\n|};\n\n// $FlowFixMe\nexport function serializeError({ message, stack, code } : Error) : NativeSerializedType<typeof TYPE.ERROR, SerializedError> {\n    return serializeType(TYPE.ERROR, { message, stack, code });\n}\n\nexport function deserializeError({ message, stack, code } : SerializedError) : Error {\n    const error = new Error(message);\n    // $FlowFixMe\n    error.code = code;\n    error.stack = `${ stack }\\n\\n${ error.stack }`;\n    return error;\n}\n","/* @flow */\n\nexport type SerializedPromise = void;\n\nexport function serializePromise() : SerializedPromise {\n    // pass\n}\n\nexport function deserializePromise() {\n    throw new Error(`Promise serialization is not implemented; nothing to deserialize`);\n}\n","/* @flow */\n\nimport { serializeType } from '../common';\nimport { TYPE } from '../constants';\nimport type { NativeSerializedType } from '../types';\n\nexport type SerializedRegex = string;\n\nexport function serializeRegex(val : RegExp) : NativeSerializedType<typeof TYPE.REGEX, SerializedRegex> {\n    return serializeType(TYPE.REGEX, val.source);\n}\n\nexport function deserializeRegex(val : string) : RegExp {\n    // eslint-disable-next-line security/detect-non-literal-regexp\n    return new RegExp(val);\n}\n","/* @flow */\n\nimport { serializeType } from '../common';\nimport { TYPE } from '../constants';\nimport type { NativeSerializedType } from '../types';\n\nexport type SerializedDate = string;\n\nexport function serializeDate(val : Date) : NativeSerializedType<typeof TYPE.DATE, SerializedDate> {\n    return serializeType(TYPE.DATE, val.toJSON());\n}\n\nexport function deserializeDate(val : string) : Date {\n    return new Date(val);\n}\n","/* @flow */\n\nexport type SerializedArray<T : mixed = mixed> = $ReadOnlyArray<T>;\n\nexport function serializeArray<T : mixed>(val : $ReadOnlyArray<T>) : SerializedArray<T> {\n    return val;\n}\n\nexport function deserializeArray<T : mixed>(val : SerializedArray<T>) : $ReadOnlyArray<T> {\n    return val;\n}\n","/* @flow */\n\nexport type SerializedObject = Object;\n\nexport function serializeObject(val : Object) : SerializedObject {\n    return val;\n}\n\nexport function deserializeObject(val : SerializedObject) : Object {\n    return val;\n}\n","/* @flow */\n\nexport type SerializedString = string;\n\nexport function serializeString(val : string) : SerializedString {\n    return val;\n}\n\nexport function deserializeString(val : SerializedString) : string {\n    return val;\n}\n","/* @flow */\n\nexport type SerializedNumber = number;\n\nexport function serializeNumber(val : number) : SerializedNumber {\n    return val;\n}\n\nexport function deserializeNumber(val : SerializedNumber) : number {\n    return val;\n}\n","/* @flow */\n\nexport type SerializedBoolean = boolean;\n\nexport function serializeBoolean(val : boolean) : SerializedBoolean {\n    return val;\n}\n\nexport function deserializeBoolean(val : SerializedBoolean) : boolean {\n    return val;\n}\n","/* @flow */\n\nexport type SerializedNull = null;\n\nexport function serializeNull(val : null) : SerializedNull {\n    return val;\n}\n\nexport function deserializeNull(val : SerializedNull) : null {\n    return val;\n}\n","/* @flow */\n\nimport { TYPE } from './constants';\nimport type { Thenable, CustomSerializedType, NativeSerializedType } from './types';\nimport { determineType, isSerializedType } from './common';\nimport {\n    serializeFunction,\n    serializeError, type SerializedError,\n    serializePromise,\n    serializeRegex, type SerializedRegex,\n    serializeDate, type SerializedDate,\n    serializeArray,\n    serializeObject,\n    serializeString,\n    serializeNumber,\n    serializeBoolean,\n    serializeNull\n} from './serializers';\n\ntype NativeSerializer<V : mixed, S : mixed, T : $Values<typeof TYPE>> = (value : V, key : string) => NativeSerializedType<T, S>;\ntype CustomSerializer<V : mixed, S : mixed, T : string> = (value : V, key : string) => CustomSerializedType<T, S>;\ntype PrimitiveSerializer<V : mixed, S : mixed> = (value : V, key : string) => S;\ntype CustomOrPrimitiveSerializer<V : mixed, T : string> = CustomSerializer<V, *, T> | PrimitiveSerializer<V, *>;\ntype NativeOrCustomOrPrimitiveSerializer<V : mixed, S : mixed, T : string> = NativeSerializer<V, S, T> | CustomOrPrimitiveSerializer<V, T>;\n\ntype Serializers = {|\n    function? : CustomOrPrimitiveSerializer<Function, typeof TYPE.FUNCTION>,\n    error? : NativeOrCustomOrPrimitiveSerializer<Error, SerializedError, typeof TYPE.ERROR>,\n    promise? : CustomOrPrimitiveSerializer<Thenable, typeof TYPE.PROMISE>,\n    regex? : NativeOrCustomOrPrimitiveSerializer<RegExp, SerializedRegex, typeof TYPE.REGEX>,\n    date? : NativeOrCustomOrPrimitiveSerializer<Date, SerializedDate, typeof TYPE.DATE>,\n    array? : CustomOrPrimitiveSerializer<$ReadOnlyArray<mixed>, typeof TYPE.ARRAY>,\n    object? : CustomOrPrimitiveSerializer<Object, typeof TYPE.OBJECT>,\n    string? : CustomOrPrimitiveSerializer<string, typeof TYPE.STRING>,\n    number? : CustomOrPrimitiveSerializer<number, typeof TYPE.NUMBER>,\n    boolean? : CustomOrPrimitiveSerializer<boolean, typeof TYPE.BOOLEAN>,\n    null? : CustomOrPrimitiveSerializer<null, typeof TYPE.NULL>\n|};\n\nconst SERIALIZER : Serializers = {\n    [ TYPE.FUNCTION ]:  serializeFunction,\n    [ TYPE.ERROR ]:     serializeError,\n    [ TYPE.PROMISE ]:   serializePromise,\n    [ TYPE.REGEX ]:     serializeRegex,\n    [ TYPE.DATE ]:      serializeDate,\n    [ TYPE.ARRAY ]:     serializeArray,\n    [ TYPE.OBJECT ]:    serializeObject,\n    [ TYPE.STRING ]:    serializeString,\n    [ TYPE.NUMBER ]:    serializeNumber,\n    [ TYPE.BOOLEAN ]:   serializeBoolean,\n    [ TYPE.NULL ]:      serializeNull\n};\n\n// $FlowFixMe\nconst defaultSerializers : Serializers = {};\n\nexport function serialize<T : mixed>(obj : T, serializers : Serializers = defaultSerializers) : string {\n\n    function replacer(key) : ?mixed {\n        const val = this[key];\n\n        if (isSerializedType(this)) {\n            return val;\n        }\n        \n        const type = determineType(val);\n\n        if (!type) {\n            return val;\n        }\n\n        // $FlowFixMe\n        const serializer = serializers[type] || SERIALIZER[type];\n\n        if (!serializer) {\n            return val;\n        }\n\n        return serializer(val, key);\n    }\n\n    const result = JSON.stringify(obj, replacer);\n\n    if (typeof result === 'undefined') {\n        return TYPE.UNDEFINED;\n    }\n\n    return result;\n}\n","/* @flow */\n\nimport type { Thenable } from './types';\nimport { TYPE } from './constants';\nimport { determineType, isSerializedType } from './common';\nimport {\n    deserializeFunction,\n    deserializeError, type SerializedError,\n    deserializePromise,\n    deserializeRegex, type SerializedRegex,\n    deserializeDate, type SerializedDate,\n    deserializeArray,\n    deserializeObject,\n    deserializeString,\n    deserializeNumber,\n    deserializeBoolean,\n    deserializeNull\n} from './serializers';\n\ntype Deserializer<V : mixed, S : mixed> = (serializedValue : S, key : string) => V;\ntype PrimitiveDeserializer<V, S = V> = (serializedValue : S, key : string) => V;\n\ntype Deserializers = {\n    function? : Deserializer<Function, *>,\n    error? : Deserializer<Error, SerializedError>,\n    promise? : Deserializer<Thenable, *>,\n    regex? : Deserializer<RegExp, SerializedRegex>,\n    date? : Deserializer<Date, SerializedDate>,\n    array? : PrimitiveDeserializer<$ReadOnlyArray<mixed>>,\n    object? : PrimitiveDeserializer<Object>,\n    string? : PrimitiveDeserializer<string>,\n    number? : PrimitiveDeserializer<number>,\n    boolean? : PrimitiveDeserializer<boolean>,\n    null? : PrimitiveDeserializer<null>,\n    [string] : Deserializer<mixed, *>\n};\n\n// $FlowFixMe\nconst DESERIALIZER : Deserializers = {\n    [ TYPE.FUNCTION ]:  deserializeFunction,\n    [ TYPE.ERROR ]:     deserializeError,\n    [ TYPE.PROMISE ]:   deserializePromise,\n    [ TYPE.REGEX ]:     deserializeRegex,\n    [ TYPE.DATE ]:      deserializeDate,\n    [ TYPE.ARRAY ]:     deserializeArray,\n    [ TYPE.OBJECT ]:    deserializeObject,\n    [ TYPE.STRING ]:    deserializeString,\n    [ TYPE.NUMBER ]:    deserializeNumber,\n    [ TYPE.BOOLEAN ]:   deserializeBoolean,\n    [ TYPE.NULL ]:      deserializeNull\n};\n\n// $FlowFixMe\nconst defaultDeserializers : Deserializers = {};\n\nexport function deserialize<T : mixed | null | void>(str : string, deserializers : Deserializers = defaultDeserializers) : T {\n    if (str === TYPE.UNDEFINED) {\n        // $FlowFixMe\n        return;\n    }\n\n    function replacer(key, val) : ?mixed {\n        if (isSerializedType(this)) {\n            return val;\n        }\n\n        let type;\n        let value;\n\n        if (isSerializedType(val)) {\n            type = val.__type__;\n            value = val.__val__;\n        } else {\n            type = determineType(val);\n            value = val;\n        }\n\n        if (!type) {\n            return value;\n        }\n\n        // $FlowFixMe\n        const deserializer = deserializers[type] || DESERIALIZER[type];\n\n        if (!deserializer) {\n            return value;\n        }\n\n        return deserializer(value, key);\n    }\n\n    return JSON.parse(str, replacer);\n}\n","/* @flow */\n\nimport { TYPE } from './constants';\n\n// export something to force webpack to see this as an ES module\nexport const TYPES = true;\n\n// eslint-disable-next-line flowtype/require-exact-type\nexport type Thenable = {\n    then : (onSuccess? : (val? : mixed) => mixed, onError? : (err? : mixed) => mixed) => Thenable,\n    catch : (onError? : (err? : mixed) => mixed) => Thenable\n};\n\n// eslint-disable-next-line flowtype/require-exact-type\nexport type NativeSerializedType<T : $Values<typeof TYPE>, V : mixed> = {\n    __type__ : T,\n    __val__ : V\n};\n\nexport type CustomSerializedType<T : string, V : mixed> = {|\n    __type__ : T,\n    __val__ : V\n|};\n"],"sourceRoot":""}